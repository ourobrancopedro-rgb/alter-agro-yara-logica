{
  "name": "YARA Lógica PICC Notarization",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "yara/picc/notarize",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "<SET_IN_N8N>"
    },
    {
      "parameters": {
        "functionCode": "// HMAC Validation + Canonical Hash + Schema Validation\nconst crypto = require('crypto');\n\n// 1. Extract request body and signature\nconst body = $input.item.json.body;\nconst receivedSig = $input.item.json.headers['x-signature-256'] || '';\nconst hmacSecret = $env.HMAC_SECRET || '<SET_IN_N8N>';\n\n// 2. Compute expected HMAC\nconst bodyStr = JSON.stringify(body);\nconst expectedSig = 'sha256=' + crypto.createHmac('sha256', hmacSecret).update(bodyStr).digest('hex');\n\n// 3. Validate signature\nif (receivedSig !== expectedSig) {\n  return [{ json: { ok: false, code: 'BAD_SIG', msg: 'HMAC signature mismatch' } }];\n}\n\n// 4. Validate timestamp window (≤ 300s)\nconst now = Math.floor(Date.now() / 1000);\nconst ts = body.ts || 0;\nif (Math.abs(now - ts) > 300) {\n  return [{ json: { ok: false, code: 'TS_WINDOW', msg: 'Timestamp outside 5min window' } }];\n}\n\n// 5. Basic schema validation\nif (!body.schema_version || body.schema_version !== 'PICC-1.0') {\n  return [{ json: { ok: false, code: 'SCHEMA_VERSION', msg: 'Invalid or missing schema_version' } }];\n}\nif (!body.nonce || body.nonce.length < 8 || body.nonce.length > 128) {\n  return [{ json: { ok: false, code: 'NONCE_INVALID', msg: 'Nonce must be 8-128 chars' } }];\n}\nif (!body.decision || !body.decision.question || !body.decision.conclusion || !body.decision.premises || !body.decision.falsifier) {\n  return [{ json: { ok: false, code: 'DECISION_INCOMPLETE', msg: 'Decision missing required fields' } }];\n}\n\n// 6. Validate FACT ≥ 2 evidence (HTTPS-only)\nfor (const p of body.decision.premises) {\n  if (p.type === 'FACT') {\n    if (!p.evidence || !Array.isArray(p.evidence) || p.evidence.length < 2) {\n      return [{ json: { ok: false, code: 'FACT_EVIDENCE', msg: 'FACT premises require ≥2 evidence URLs' } }];\n    }\n    for (const url of p.evidence) {\n      if (!url.startsWith('https://')) {\n        return [{ json: { ok: false, code: 'EVIDENCE_HTTPS', msg: 'Evidence URLs must be HTTPS' } }];\n      }\n    }\n  }\n}\n\n// 7. Canonical JSON (sorted keys) + SHA-256 hash\nfunction canonical(obj) {\n  if (Array.isArray(obj)) return '[' + obj.map(canonical).join(',') + ']';\n  if (obj && typeof obj === 'object') {\n    const keys = Object.keys(obj).sort();\n    return '{' + keys.map(k => JSON.stringify(k) + ':' + canonical(obj[k])).join(',') + '}';\n  }\n  return JSON.stringify(obj);\n}\n\nconst canonicalStr = canonical(body);\nconst hash = crypto.createHash('sha256').update(canonicalStr).digest('hex');\nconst hashLabel = hash.substring(0, 16);\n\n// 8. Return validated payload + hash + metadata\nreturn [{\n  json: {\n    ok: true,\n    payload: body,\n    hash_full: hash,\n    hash_label: hashLabel,\n    canonical: canonicalStr,\n    metadata: {\n      actor: body.metadata?.actor || 'unknown',\n      context: body.metadata?.context || 'default',\n      ts: ts,\n      nonce: body.nonce\n    }\n  }\n}];"
      },
      "id": "validate-hash-function",
      "name": "Validate + Hash",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.ok}}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-valid",
      "name": "IF Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Format decision as GitHub Issue Markdown\nconst p = $input.item.json.payload;\nconst meta = $input.item.json.metadata;\nconst hash = $input.item.json.hash_full;\nconst hashLabel = $input.item.json.hash_label;\n\n// Build premises section\nlet premisesMarkdown = '';\nfor (const prem of p.decision.premises) {\n  premisesMarkdown += `### ${prem.type}\\n${prem.text}\\n`;\n  if (prem.evidence && prem.evidence.length > 0) {\n    premisesMarkdown += '**Evidence:**\\n';\n    for (const url of prem.evidence) {\n      premisesMarkdown += `- ${url}\\n`;\n    }\n  }\n  premisesMarkdown += '\\n';\n}\n\n// Build inferences section\nlet inferencesMarkdown = '';\nif (p.decision.inferences && p.decision.inferences.length > 0) {\n  inferencesMarkdown = '## Inferences\\n';\n  for (const inf of p.decision.inferences) {\n    inferencesMarkdown += `- ${inf}\\n`;\n  }\n  inferencesMarkdown += '\\n';\n}\n\n// Build contradictions section\nlet contradictionsMarkdown = '';\nif (p.decision.contradictions && p.decision.contradictions.length > 0) {\n  contradictionsMarkdown = '## Contradictions\\n';\n  for (const con of p.decision.contradictions) {\n    contradictionsMarkdown += `- ${con}\\n`;\n  }\n  contradictionsMarkdown += '\\n';\n}\n\n// Compose full issue body\nconst issueTitle = `[PICC] ${p.decision.question}`;\nconst issueBody = `## Decision Record\n\n**Question:** ${p.decision.question}\n\n**Conclusion:** ${p.decision.conclusion}\n\n**Confidence:** ${p.decision.confidence}\n\n---\n\n## Premises\n\n${premisesMarkdown}\n\n${inferencesMarkdown}\n\n${contradictionsMarkdown}\n\n## Falsifier\n\n${p.decision.falsifier}\n\n---\n\n## Metadata\n\n- **Actor:** ${meta.actor}\n- **Context:** ${meta.context}\n- **Timestamp:** ${meta.ts} (${new Date(meta.ts * 1000).toISOString()})\n- **Nonce:** ${meta.nonce}\n- **Schema:** ${p.schema_version}\n\n---\n\n## Hash\n\n\\`\\`\\`\n${hash}\n\\`\\`\\`\n\n**Canonical JSON:**\n\\`\\`\\`json\n${$input.item.json.canonical}\n\\`\\`\\`\n`;\n\n// Labels\nconst labels = [\n  'yara-logica',\n  'picc',\n  `hash:${hashLabel}`,\n  `schema:${p.schema_version}`\n];\nif (meta.actor !== 'unknown') labels.push(`actor:${meta.actor}`);\nif (meta.context !== 'default') labels.push(`context:${meta.context}`);\n\nreturn [{\n  json: {\n    title: issueTitle,\n    body: issueBody,\n    labels: labels,\n    hash_label: hashLabel,\n    hash_full: hash\n  }\n}];"
      },
      "id": "format-markdown",
      "name": "Format → Markdown",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 200]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "issue",
        "operation": "getAll",
        "owner": "={{$env.GITHUB_OWNER || '<ORG>'}}",
        "repository": "={{$env.GITHUB_REPO || '<REPO>'}}",
        "returnAll": false,
        "limit": 10,
        "additionalFields": {
          "labels": "={{$json.hash_label}}"
        }
      },
      "id": "github-search-idempotency",
      "name": "GitHub Search (Idempotency)",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [1050, 200],
      "credentials": {
        "githubOAuth2Api": {
          "id": "<SET_IN_N8N>",
          "name": "GitHub OAuth2"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.length || 0}}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "if-not-exists",
      "name": "IF Not Exists",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "issue",
        "operation": "create",
        "owner": "={{$env.GITHUB_OWNER || '<ORG>'}}",
        "repository": "={{$env.GITHUB_REPO || '<REPO>'}}",
        "title": "={{$node['Format → Markdown'].json.title}}",
        "body": "={{$node['Format → Markdown'].json.body}}",
        "labels": "={{$node['Format → Markdown'].json.labels.join(',')}}"
      },
      "id": "github-create-issue",
      "name": "GitHub Create Issue",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [1450, 100],
      "credentials": {
        "githubOAuth2Api": {
          "id": "<SET_IN_N8N>",
          "name": "GitHub OAuth2"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{{\n  ok: true,\n  code: 'CREATED',\n  msg: 'Decision notarized',\n  issue_url: $json.html_url,\n  issue_number: $json.number,\n  hash: $node['Format → Markdown'].json.hash_full\n}}}"
      },
      "id": "respond-created",
      "name": "Respond: Created",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1650, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{{\n  ok: true,\n  code: 'IDEMPOTENT',\n  msg: 'Decision already notarized',\n  issue_url: $json[0].html_url,\n  issue_number: $json[0].number,\n  hash: $node['Format → Markdown'].json.hash_full\n}}}"
      },
      "id": "respond-idempotent",
      "name": "Respond: Idempotent",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 401,
        "responseBody": "={{$json}}"
      },
      "id": "respond-error",
      "name": "Respond: Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [850, 400]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{ "node": "Validate + Hash", "type": "main", "index": 0 }]]
    },
    "Validate + Hash": {
      "main": [[{ "node": "IF Valid", "type": "main", "index": 0 }]]
    },
    "IF Valid": {
      "main": [
        [{ "node": "Format → Markdown", "type": "main", "index": 0 }],
        [{ "node": "Respond: Error", "type": "main", "index": 0 }]
      ]
    },
    "Format → Markdown": {
      "main": [[{ "node": "GitHub Search (Idempotency)", "type": "main", "index": 0 }]]
    },
    "GitHub Search (Idempotency)": {
      "main": [[{ "node": "IF Not Exists", "type": "main", "index": 0 }]]
    },
    "IF Not Exists": {
      "main": [
        [{ "node": "GitHub Create Issue", "type": "main", "index": 0 }],
        [{ "node": "Respond: Idempotent", "type": "main", "index": 0 }]
      ]
    },
    "GitHub Create Issue": {
      "main": [[{ "node": "Respond: Created", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "picc-1.0-notarization"
}
